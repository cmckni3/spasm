#!/usr/bin/env ruby
#
# This is where you add your code for the SPASM program! Note that you can
# use any language by simply changing the `#!` ling up top ^^^.
#
# The script will be run as root like so:
#
#   # /usr/local/bin/spasm [filename]
#

require 'optparse'

# Get command line options
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: spasm [filename]"
end.parse!

# [operation] is one of mov, add, sub, mul, eq, gt, lt
# [target] is one of the general purpose registers (R1-4)
# [value] can be either a general purpose register (R1-4) or a constant

class Register
  REGISTERS = %w(R1 R2 R3 R4 CP SP)
  DATA_STORE = '/var/lib/spasm'

  def initialize(register)
    unless REGISTERS.include?(register)
      raise ArgumentError.new("Invalid register")
    end
    @register = register
  end

  def read
    File.read(register_store)
  end

  def write(value)
    File.open(register_store, 'w') do |file|
      file.write(value)
    end
  end

  def +(value)
    write(read.to_i + value.to_i)
  end

  def -(value)
    write(read.to_i - value.to_i)
  end

  def *(value)
    write(read.to_i * value.to_i)
  end

  def ==(value)
    if read.to_i == value.to_i
      Register.new('CP').write(0)
    else
      Register.new('CP').write(value.to_i)
    end
  end

  def <(value)
    if read.to_i < value.to_i
      Register.new('CP').write(0)
    else
      Register.new('CP').write(value.to_i)
    end
  end

  def >(value)
    if read.to_i > value.to_i
      Register.new('CP').write(0)
    else
      Register.new('CP').write(value.to_i)
    end
  end

  def to_i
    read.to_i
  end

  private

  def register_store
    "#{DATA_STORE}/#{@register}"
  end
end

class Operation
  def initialize(target, value)
    @target = target
    @value = value
  end

  def apply
    # noop
  end
end

class Add < Operation
  def apply
    @target + @value
  end
end

class Sub < Operation
  def apply
    @target - @value
  end
end

class Mul < Operation
  def apply
    @target * @value
  end
end

class Mov < Operation
  def apply
    @target.write(@value)
  end
end

class Eq < Operation
  def apply
    @target == @value
  end
end

class Gt < Operation
  def apply
    @target > @value
  end
end

class Lt < Operation
  def apply
    @target < @value
  end
end

class Print < Operation
  def apply
    puts @value.read
  end
end

class Exit < Operation
  def apply
    Process.exit(@value.to_i)
  end
end

# We need to keep track of labels to be able to jump
class Label < Operation
  def initialize(name, line_number)
    @name = name
    @line_number = line_number
  end

  attr_reader :name, :line_number
end

$labels = []

class Jump < Operation
  def apply
    label = find_label
    Register.new('SP').write(label.line_number)
  end

  private
  def find_label
    label = $labels.detect { |label| label.name == @value }
    return label
  end
end

class JTrue < Jump
  def apply
    if Register.new('CP').to_i == 0
      label = find_label
      Register.new('SP').write(label.line_number)
    end
  end
end

class JFalse < Jump
  def apply
    unless Register.new('CP').to_i == 0
      label = find_label
      Register.new('SP').write(label.line_number)
    end
  end
end

class Instruction
  def initialize(operation, target, value)
    @operation = operation
    @target = target
    @value = value
  end

  def run
    operation.apply
  end

  attr_reader :operation, :target, :value
end

class Program
  def initialize(filename)
    @line_number = Register.new('SP')
    @line_number.write(0)

    line_number = 0
    @instructions = File.read(filename).lines("\n").map do |line|
      line = line.strip.split(' ')

      operation = nil
      target = nil
      value = nil
      operation = line[0]
      if line.length == 2
        value     = line[1]
      else
        begin
          target = Register.new(line[1])
        rescue ArgumentError
          Process.exit(2)
        end
        value     = line[2]
      end

      begin
        value = Register.new(value)
      rescue ArgumentError
        if value[0] == '%'
          value = value[1..-1]
        end
      end

      operation = case operation
      when 'mov'
        Mov.new(target, value)
      when 'add'
        Add.new(target, value)
      when 'sub'
        Sub.new(target, value)
      when 'mul'
        Mul.new(target, value)
      when 'eq'
        Eq.new(target, value)
      when 'gt'
        Gt.new(target, value)
      when 'lt'
        Lt.new(target, value)
      when 'label'
        label = Label.new(value, line_number)
        $labels << label
        label
      when 'jump'
        Jump.new(target, value)
      when 'jtrue'
        JTrue.new(target, value)
      when 'jfalse'
        JFalse.new(target, value)
      when 'print'
        Print.new(target, value)
      when 'exit'
        Exit.new(target, value)
      else
        Process.exit(1)
      end

      line_number = line_number + 1

      Instruction.new(operation, target, value)
    end
  end

  def run
    while true
      @instructions[@line_number.read.to_i].run
      @line_number + 1
    end
  end
end

Program.new(ARGV.first).run

Process.exit(0)
